# ì½”ë”© í…ŒìŠ¤íŠ¸ #10: ë¬¸ìì—´ì—ì„œ ì²« ë²ˆì§¸ ê³ ìœ  ë¬¸ì - ë‹µë³€

## ë¬¸ì œ ìš”ì•½
ë°˜ë³µë˜ì§€ ì•ŠëŠ” ì²« ë²ˆì§¸ ë¬¸ìì˜ ì¸ë±ìŠ¤ ì°¾ê¸°. ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´ -1 ë°˜í™˜.

---

## ë‹¹ì‹ ì˜ í’€ì´ (HashMap - Two Pass)

```typescript
function solution(s: string): number {
  const map = new Map();

  // 1ë‹¨ê³„: ê° ë¬¸ìì˜ ê°œìˆ˜ ì¹´ìš´íŒ…
  for (const word of s) {
    map.set(word, map.has(word) ? map.get(word) + 1 : 1);
  }

  // 2ë‹¨ê³„: ê°œìˆ˜ê°€ 1ì¸ ì²« ë²ˆì§¸ ë¬¸ì ì°¾ê¸°
  for (let i = 0; i < s.length; i++) {
    if (map.get(s[i]) === 1) {
      return i;
    }
  }

  return -1;
}
```

### ì‹œê°„ ë³µì¡ë„
- **O(n)**: ë¬¸ìì—´ì„ ë‘ ë²ˆ ìˆœíšŒ (O(n) + O(n) = O(2n) = O(n))

### ê³µê°„ ë³µì¡ë„
- **O(k)**: këŠ” ê³ ìœ í•œ ë¬¸ì ê°œìˆ˜
- ì˜ì–´ ì†Œë¬¸ìë§Œ ì‚¬ìš©í•˜ë¯€ë¡œ ìµœëŒ€ 26ê°œ â†’ O(26) = O(1)

### ë™ì‘ ê³¼ì • (ì˜ˆì‹œ: "loveleetcode")

```
1ë‹¨ê³„: ë¬¸ì ê°œìˆ˜ ì¹´ìš´íŒ…
Map {
  'l' => 2,
  'o' => 2,
  'v' => 1,  â† ê³ ìœ !
  'e' => 4,
  't' => 1,  â† ê³ ìœ !
  'c' => 1,  â† ê³ ìœ !
  'd' => 1   â† ê³ ìœ !
}

2ë‹¨ê³„: ì²« ë²ˆì§¸ ê³ ìœ  ë¬¸ì ì°¾ê¸°
ì¸ë±ìŠ¤ 0: 'l' â†’ ê°œìˆ˜ 2 (X)
ì¸ë±ìŠ¤ 1: 'o' â†’ ê°œìˆ˜ 2 (X)
ì¸ë±ìŠ¤ 2: 'v' â†’ ê°œìˆ˜ 1 (âœ…) â†’ ë°˜í™˜ 2
```

### ì¥ì 
- ëª…í™•í•œ Two-Pass ì ‘ê·¼
- ì‚¼í•­ ì—°ì‚°ìë¡œ ê°„ê²°í•œ ì½”ë“œ
- O(n) ì‹œê°„ ë³µì¡ë„
- for...of ë¬¸ë²• ì‚¬ìš©ìœ¼ë¡œ ê°€ë…ì„± ì¢‹ìŒ

---

## í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ì˜¤ë¥˜ ë°œê²¬!

ë‹¹ì‹ ì´ ì˜ ì°¾ì•„ë‚¸ ì˜¤ë¥˜:
```
ì…ë ¥: "aabbccddeff"
ë¶„ì„:
  a: 2ê°œ (ì¸ë±ìŠ¤ 0, 1)
  b: 2ê°œ (ì¸ë±ìŠ¤ 2, 3)
  c: 2ê°œ (ì¸ë±ìŠ¤ 4, 5)
  d: 2ê°œ (ì¸ë±ìŠ¤ 6, 7)
  e: 1ê°œ (ì¸ë±ìŠ¤ 8) â† ì²« ë²ˆì§¸ ê³ ìœ  ë¬¸ì!
  f: 2ê°œ (ì¸ë±ìŠ¤ 9, 10)

ì˜¬ë°”ë¥¸ ë‹µ: 8 (eì˜ ì¸ë±ìŠ¤)
ì›ë˜ í…ŒìŠ¤íŠ¸: 9 (ì˜ëª»ëœ ê°’)
```

í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë¥¼ ìˆ˜ì •í–ˆìŠµë‹ˆë‹¤! ğŸ‘

---

## ë‹¤ë¥¸ í’€ì´ ë°©ë²•ë“¤

### ë°©ë²• 1: ë°°ì—´ ì¹´ìš´í„° (ê³µê°„ ìµœì í™”)

```typescript
function solution(s: string): number {
  const count: number[] = new Array(26).fill(0);

  // ê° ë¬¸ì ê°œìˆ˜ ì¹´ìš´íŒ…
  for (const char of s) {
    count[char.charCodeAt(0) - 97]++; // 'a'ì˜ ASCIIëŠ” 97
  }

  // ê°œìˆ˜ê°€ 1ì¸ ì²« ë²ˆì§¸ ë¬¸ì ì°¾ê¸°
  for (let i = 0; i < s.length; i++) {
    if (count[s.charCodeAt(i) - 97] === 1) {
      return i;
    }
  }

  return -1;
}
```

**ì‹œê°„ ë³µì¡ë„**: O(n)
**ê³µê°„ ë³µì¡ë„**: O(1) - ë°°ì—´ í¬ê¸° ê³ ì • (26)
**ì¥ì **:
- ë°°ì—´ ì¸ë±ìŠ¤ ì ‘ê·¼ì´ Mapë³´ë‹¤ ì•½ê°„ ë¹ ë¦„
- ê³µê°„ ë³µì¡ë„ê°€ ì—„ê²©í•˜ê²Œ O(1)
**ë‹¨ì **:
- ASCII ì½”ë“œ ê³„ì‚° í•„ìš”
- ì˜ì–´ ì†Œë¬¸ìë§Œ ê°€ëŠ¥

---

### ë°©ë²• 2: indexOf + lastIndexOf (ê°„ê²°)

```typescript
function solution(s: string): number {
  for (let i = 0; i < s.length; i++) {
    // ì²« ë“±ì¥ ìœ„ì¹˜ì™€ ë§ˆì§€ë§‰ ë“±ì¥ ìœ„ì¹˜ê°€ ê°™ìœ¼ë©´ ê³ ìœ 
    if (s.indexOf(s[i]) === s.lastIndexOf(s[i])) {
      return i;
    }
  }
  return -1;
}
```

**ì‹œê°„ ë³µì¡ë„**: O(nÂ²) - ê° ë¬¸ìë§ˆë‹¤ indexOfì™€ lastIndexOf í˜¸ì¶œ (O(n) Ã— n)
**ê³µê°„ ë³µì¡ë„**: O(1)
**ì¥ì **:
- ì½”ë“œê°€ ë§¤ìš° ê°„ê²°
- ì§ê´€ì ì¸ ë¡œì§
**ë‹¨ì **:
- ì‹œê°„ ë³µì¡ë„ê°€ O(nÂ²)ë¡œ ë¹„íš¨ìœ¨ì 
- í° ë¬¸ìì—´ì—ì„œëŠ” ëŠë¦¼

---

### ë°©ë²• 3: Set + ë‘ ë²ˆì§¸ ì¹´ìš´í„° (ë³µì¡)

```typescript
function solution(s: string): number {
  const seen = new Set<string>();
  const duplicates = new Set<string>();

  // ì¤‘ë³µ ë¬¸ì ì¶”ì 
  for (const char of s) {
    if (seen.has(char)) {
      duplicates.add(char);
    } else {
      seen.add(char);
    }
  }

  // ì²« ë²ˆì§¸ ê³ ìœ  ë¬¸ì ì°¾ê¸°
  for (let i = 0; i < s.length; i++) {
    if (!duplicates.has(s[i])) {
      return i;
    }
  }

  return -1;
}
```

**ì‹œê°„ ë³µì¡ë„**: O(n)
**ê³µê°„ ë³µì¡ë„**: O(k)
**ì¥ì **:
- O(n) ì‹œê°„ ë³µì¡ë„
**ë‹¨ì **:
- ë‘ ê°œì˜ Set ì‚¬ìš©ìœ¼ë¡œ ë³µì¡ë„ ì¦ê°€
- HashMap ë°©ì‹ë³´ë‹¤ ëª…í™•í•˜ì§€ ì•ŠìŒ

---

## ì„±ëŠ¥ ë¹„êµ

| ë°©ë²• | ì‹œê°„ ë³µì¡ë„ | ê³µê°„ ë³µì¡ë„ | ì½”ë“œ ê°„ê²°ì„± | ì¶”ì²œë„ |
|------|------------|------------|-----------|--------|
| HashMap (ë‹¹ì‹ ì˜ í’€ì´) | O(n) | O(k) | â­â­â­â­â­ | â­â­â­â­â­ |
| ë°°ì—´ ì¹´ìš´í„° | O(n) | O(1) | â­â­â­â­ | â­â­â­â­â­ |
| indexOf + lastIndexOf | O(nÂ²) | O(1) | â­â­â­â­â­ | â­â­ |
| Set (ì¤‘ë³µ ì¶”ì ) | O(n) | O(k) | â­â­â­ | â­â­â­ |

---

## ì‹¤í–‰ ê²°ê³¼

```
ì´ 6ê°œ ì¤‘ 6ê°œ í†µê³¼
í‰ê·  ì‹¤í–‰ ì‹œê°„: 0.0137ms
ì´ ì‹¤í–‰ ì‹œê°„: 0.0821ms
```

ëª¨ë“  í…ŒìŠ¤íŠ¸ë¥¼ í†µê³¼í–ˆê³ , í‰ê·  **0.0137ms**ì˜ ë¹ ë¥¸ ì‹¤í–‰ ì‹œê°„ì„ ê¸°ë¡í–ˆìŠµë‹ˆë‹¤!

---

## ì½”ë“œ ê°œì„  ì œì•ˆ

í˜„ì¬ ì½”ë“œë„ í›Œë¥­í•˜ì§€ë§Œ, ì•½ê°„ ë” ê°„ê²°í•˜ê²Œ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤:

```typescript
function solution(s: string): number {
  const count = new Map<string, number>();

  // ì¹´ìš´íŒ… (ë” ê°„ê²°í•œ ë°©ì‹)
  for (const char of s) {
    count.set(char, (count.get(char) || 0) + 1);
  }

  // ì²« ë²ˆì§¸ ê³ ìœ  ë¬¸ì ì°¾ê¸°
  for (let i = 0; i < s.length; i++) {
    if (count.get(s[i]) === 1) {
      return i;
    }
  }

  return -1;
}
```

**ë³€ê²½ ì‚¬í•­:**
- `(count.get(char) || 0) + 1` íŒ¨í„´ ì‚¬ìš© (ë” ì¼ë°˜ì )
- ë³€ìˆ˜ëª… `map` â†’ `count` (ì˜ë„ê°€ ë” ëª…í™•)
- ë³€ìˆ˜ëª… `word` â†’ `char` (ë¬¸ì í•˜ë‚˜ë¥¼ ë‚˜íƒ€ëƒ„)

---

## í•µì‹¬ ê°œë…

1. **Two-Pass ì ‘ê·¼**:
   - ì²« ë²ˆì§¸ ìˆœíšŒ: ê° ë¬¸ìì˜ ê°œìˆ˜ ì¹´ìš´íŒ…
   - ë‘ ë²ˆì§¸ ìˆœíšŒ: ê°œìˆ˜ê°€ 1ì¸ ì²« ë²ˆì§¸ ë¬¸ì ì°¾ê¸°

2. **HashMapì„ ì‚¬ìš©í•œ ë¹ˆë„ ì¹´ìš´íŒ…**:
   - ê° ë¬¸ìë¥¼ í‚¤ë¡œ, ê°œìˆ˜ë¥¼ ê°’ìœ¼ë¡œ ì €ì¥
   - O(1) ì¡°íšŒ/ì‚½ì… ì‹œê°„

3. **ìˆœì„œ ë³´ì¥**:
   - ë‘ ë²ˆì§¸ ìˆœíšŒë¥¼ ìˆœì°¨ì ìœ¼ë¡œ í•˜ë¯€ë¡œ "ì²« ë²ˆì§¸" ê³ ìœ  ë¬¸ìë¥¼ ìë™ìœ¼ë¡œ ì°¾ìŒ

---

## ì‹¤ì „ í™œìš©

ì´ íŒ¨í„´ì€ ë§ì€ ë¬¸ì œì—ì„œ ì‚¬ìš©ë©ë‹ˆë‹¤:

### 1. ì²« ë²ˆì§¸ ë°˜ë³µ ë¬¸ì ì°¾ê¸° (ë°˜ëŒ€ ë¬¸ì œ)

```typescript
function firstRepeatedChar(s: string): number {
  const seen = new Set<string>();

  for (let i = 0; i < s.length; i++) {
    if (seen.has(s[i])) {
      return i; // ì²« ë²ˆì§¸ ë°˜ë³µ ë¬¸ì
    }
    seen.add(s[i]);
  }

  return -1;
}
```

### 2. ê°€ì¥ ë¹ˆë²ˆí•œ ë¬¸ì ì°¾ê¸°

```typescript
function mostFrequentChar(s: string): string {
  const count = new Map<string, number>();
  let maxChar = '';
  let maxCount = 0;

  for (const char of s) {
    const newCount = (count.get(char) || 0) + 1;
    count.set(char, newCount);

    if (newCount > maxCount) {
      maxCount = newCount;
      maxChar = char;
    }
  }

  return maxChar;
}
```

### 3. ëª¨ë“  ê³ ìœ  ë¬¸ì ì°¾ê¸°

```typescript
function allUniqueChars(s: string): string[] {
  const count = new Map<string, number>();

  for (const char of s) {
    count.set(char, (count.get(char) || 0) + 1);
  }

  const unique: string[] = [];
  for (const char of s) {
    if (count.get(char) === 1 && !unique.includes(char)) {
      unique.push(char);
    }
  }

  return unique;
}
```

---

## ê²°ë¡ 

HashMapì„ ì‚¬ìš©í•œ Two-Pass ì ‘ê·¼ìœ¼ë¡œ O(n) ì‹œê°„ ë³µì¡ë„ë¡œ íš¨ìœ¨ì ìœ¼ë¡œ ë¬¸ì œë¥¼ í•´ê²°í–ˆìŠµë‹ˆë‹¤!

**ë‹¹ì‹ ì˜ í’€ì´ í•˜ì´ë¼ì´íŠ¸:**
- âœ… ì •í™•í•œ ì•Œê³ ë¦¬ì¦˜ ì„ íƒ
- âœ… ì‚¼í•­ ì—°ì‚°ìë¡œ ê°„ê²°í•œ ì½”ë“œ
- âœ… for...of ë¬¸ë²•ìœ¼ë¡œ ê°€ë…ì„± í–¥ìƒ
- âœ… í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ì˜¤ë¥˜ ë°œê²¬! (ë¬¸ì œ í•´ê²° ëŠ¥ë ¥ ìš°ìˆ˜)

í‰ê·  ì‹¤í–‰ ì‹œê°„ **0.0137ms**ëŠ” ë§¤ìš° ë¹ ë¥¸ ì„±ëŠ¥ì…ë‹ˆë‹¤! ğŸ‘
